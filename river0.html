<!DOCTYPE html>
<html>
<head>
    <title>canoaGame by espadaysantacruz SC</title>
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <script src="/libs/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

    // global variables
    var renderer;
    var scene;
    var camera;
    var ambientLight;
    var plane0, plane1;
    var planeGeometry, planeTexture, planeMaterial;
    var canoa0, canoa1;
    var flechaUP, flechaDOWN, flechaGeometry, flechaTexture, flechaMaterial;
    var meta, megaGeometry, metaTexture, metaMaterial;
    var remando0, remando1;
    var canoaGeometry, canoaTexture0, canoaTexture1, canoaMaterial0, canoaMaterial1;
    var remoGeometry, remoMaterial;
    var gyro0, gyro1;
    var acc0, acc1;
    var remo0, remo1;
    var speedX0, speedX1;
    var refX0, refX1;
    var socket;
    var rockPositions, rockTextures;
    var indice0, indice1;

    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4200);
        // position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 650;

        ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        gyro0 = 0;
        gyro1 = 0;

        acc0 = 0;
        acc1 = 0;

        speedX0 = 0;
        speedX1 = 0;

        refX0 = 0;
        refX1 = 0;

        remando0 = false;
        remando1 = false;

        initRiver();
        initCanoas();

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        render();
    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {
        // render using requestAnimationFrame
        updateRiver();
        updateCanoas();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }


    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    function initRiver() {

        // create the ground plane
        planeGeometry = new THREE.PlaneGeometry(1920, 1080);
        planeTexture = THREE.ImageUtils.loadTexture( "/img/fondo.png" );
        planeTexture.minFilter = THREE.NearestFilter;
        planeMaterial = new THREE.MeshLambertMaterial({color: 'white', map: planeTexture });
        plane0 = new THREE.Mesh(planeGeometry, planeMaterial);
        plane1 = new THREE.Mesh(planeGeometry, planeMaterial);
        plane0.receiveShadow = true;
        plane1.receiveShadow = true;

        // rotate and position the plane
        //plane.rotation.x = -0.0 * Math.PI20
        plane0.position.x = 0;
        plane0.position.y = 0;
        plane0.position.z = 0;

        plane1.position.x = 0; 
        plane1.position.y = 1080; 
        plane1.position.z = 0; 

        // add the plane to the scene
        scene.add(plane0);
        scene.add(plane1);

        // Create the meta
        metaGeometry = new THREE.PlaneGeometry(1704,400);
        metaTexture = THREE.ImageUtils.loadTexture( "/img/meta.png" );
        metaTexture.minFilter = THREE.NearestFilter;
        metaMaterial = new THREE.MeshLambertMaterial({transparent: true, map: metaTexture});
        meta = new THREE.Mesh(metaGeometry, metaMaterial);
        meta.position.x = 0;
        meta.position.y = 10000;
        meta.position.z = 20;
        scene.add(meta);

                
    }

    function updateRiver() {

        console.log(plane0.position.y - canoa0.position.y);
        console.log(plane1.position.y - canoa0.position.y);
        if (plane0.position.y - canoa0.position.y < -1080) plane0.position.y += 2 * 1080;
        if (plane1.position.y - canoa0.position.y < -1080) plane1.position.y += 2 * 1080;

    }

    function initRocas() {


    }

    function updateRocas() {


    }

    function initCanoas() {


        canoaGeometry = new THREE.BoxGeometry(360, 512, 1);
        remoGeometry = new THREE.BoxGeometry(10, 20, 10);
        flechaGeometry = new THREE.BoxGeometry(70, 50, 1);

        canoaTexture0 = {};
        canoaTexture1 = {};

        for (var i = 0; i < 10; i++) {

            var name0 = "/img/1_" + (i+1).toString() + ".png";
            var name1 = "/img/2_" + (i+1).toString() + ".png";

            canoaTexture0[i] = THREE.ImageUtils.loadTexture( name0 );
            canoaTexture1[i] = THREE.ImageUtils.loadTexture( name1 );

        }
        canoaTexture0.minFilter = THREE.NearestFilter;
        canoaTexture1.minFilter = THREE.NearestFilter;
        canoaMaterial0 = new THREE.MeshLambertMaterial({ map: canoaTexture0[0],  transparent: true });
        canoaMaterial1 = new THREE.MeshLambertMaterial({ map: canoaTexture1[0],  transparent: true });
        remoMaterial = new THREE.MeshLambertMaterial({color: 'black', transparent: true});
        
        flechaTexture = THREE.ImageUtils.loadTexture( "/img/flecha.png" );
        flechaMaterial = new THREE.MeshLambertMaterial({ map: flechaTexture, transparent: true });


        socket = io();

        // Creamos la canoa del jugador 0
        canoa0 = new THREE.Mesh(canoaGeometry, canoaMaterial0);
        remo0 = new THREE.Mesh(remoGeometry, remoMaterial);
        flechaUP = new THREE.Mesh(flechaGeometry, flechaMaterial);
        flechaDOWN = new THREE.Mesh(flechaGeometry, flechaMaterial);


        canoa0.castShadow = true;

        canoa0.position.x = -200; 
        canoa0.position.y = 0;
        canoa0.position.z = 10;
   
        remo0.position.x = -200;
        remo0.position.y = 0;        
        remo0.position.z = -500;

        scene.add(canoa0);
        scene.add(remo0);

        socket.on('acc0', function(msg){
            acc0 =  [Math.floor(msg[0]), Math.floor(msg[1]), Math.floor(msg[2])];
            gyro0 = computeQuaternionFromEulers(acc0[0], acc0[1], acc0[2]);

        });

        // Creamos la canoa del jugador 1
        canoa1 = new THREE.Mesh(canoaGeometry, canoaMaterial1);
        remo1 = new THREE.Mesh(remoGeometry, remoMaterial);

        canoa1.castShadow = true;

        canoa1.position.x = 200;
        canoa1.position.y = 0;
        canoa1.position.z = 10; 

        remo1.position.x = 200;
        remo1.position.y = 0;        
        remo1.position.z = -50;

        // Creamos la flecha

        flechaUP.position.x = 190;
        flechaUP.position.y = 0;
        flechaUP.position.z = -50;
        flechaUP.rotation.z = Math.PI;

        flechaDOWN.position.x = 190;
        flechaDOWN.position.y = 0;
        flechaDOWN.position.z = -50;

        scene.add(canoa1);
        scene.add(remo1);
        scene.add(flechaUP);
        scene.add(flechaDOWN);

        socket.on('acc1', function(msg){
            acc1 =  [Math.floor(msg[0]), Math.floor(msg[1]), Math.floor(msg[2])];
            gyro1 = computeQuaternionFromEulers(acc1[0], acc1[1], acc1[2]);

        });        

        indice0 = 0;
        indice1 = 0;

    }

    function updateCanoas() {

        // Calculamos el avance de la canoa 0
        remo0.setRotationFromQuaternion(gyro0);

        if (refX0- remo0.rotation.x > 0.05) {

            speedX0 = speedX0 + 0.2;
            remando0 = true;

        }

        refX0 = remo0.rotation.x;
            
        canoa0.position.y = canoa0.position.y + speedX0;
        if (speedX0 > 5) speedX0 = 5;
        if (speedX0 > 0) speedX0 = speedX0 - 0.03;
        if (speedX0 < 0) speedX0 = 0;

        if (remando0) {
            
            indice0 = indice0 + 1;

            if (indice0 == 30) {
                indice0 = 0;
                remando0 = false;
            }

            canoa0.material.map = canoaTexture0[Math.floor(indice0/3)];
            canoa0.material.needsUpdate = true;

        }

        else indice = 0;


        // Calculamos el avance de la canoa 1
        remo1.setRotationFromQuaternion(gyro1);


        if (refX1- remo1.rotation.x > 0.05) {

            speedX1 = speedX1 + 0.2;
            remando1 = true;
                
        }

        refX1 = remo1.rotation.x;
            
        canoa1.position.y = canoa1.position.y + speedX1;
        if (speedX1 > 5) speedX1 = 5;
        if (speedX1 > 0) speedX1 = speedX1 - 0.03;
        if (speedX1 < 0) speedX1 = 0;

        if (remando1) {
            
            indice1 = indice1 + 1;

            if (indice1 == 30) {
                indice1 = 0;
                remando1 = false;
            }
            canoa1.material.map = canoaTexture1[Math.floor(indice1/3)];
            canoa1.material.needsUpdate = true;

        }

        else indice1 = 0;

        // Calculamos el avance de la cámara
        camera.position.y = canoa0.position.y + 300;
        
        if (canoa0.position.y - canoa1.position.y > 450) {

            flechaDOWN.position.y = canoa0.position.y + 20;
            flechaDOWN.position.z = 50;

        }

        else if (canoa0.position.y - canoa1.position.y < -450) {

             flechaUP.position.y = canoa0.position.y + 580;
             flechaUP.position.z = 50; 

         }

        else {

            flechaUP.position.z = -10;
            flechaDOWN.position.z = -10;
        }

    }

    function computeQuaternionFromEulers(alpha, beta, gamma) {

        var degtorad = Math.PI / 180;
        var _x = beta * degtorad ; // beta value
        var _y = gamma * degtorad ; // gamma value
        var _z = alpha * degtorad ; // alpha value

        var cX = Math.cos( _x/2 );
        var cY = Math.cos( _y/2 );
        var cZ = Math.cos( _z/2 );
        var sX = Math.sin( _x/2 );
        var sY = Math.sin( _y/2 );
        var sZ = Math.sin( _z/2 );

        //
        // ZXY quaternion construction.
        //

        var w = cX * cY * cZ - sX * sY * sZ;
        var x = sX * cY * cZ - cX * sY * sZ;
        var y = cX * sY * cZ + sX * cY * sZ;
        var z = cX * cY * sZ + sX * sY * cZ;

        //return [ w, x, y, z ];
        return {"x":x,"y":y,"z":z,"w":w};//return a simple object with the four quaternion values

    }

    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

</script>
<body>
</body>
</html>